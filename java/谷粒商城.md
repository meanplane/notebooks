## docker

### 0 命令

```shell
docker images #查看所有镜像
docker image rm ** #删除镜像

docker ps -a #查看所有container
docker rm [containerID] #删除container
docker kill [containerID] #杀死container
docker stop [containerID] 
docker restart [containerID] 

docker container run -p 8000:3000 -it koa-demo /bin/bash
# -it参数:容器的shell映射到当前的shell,你再本机窗口输入的命令,会传入容器.
# -p参数:(-p 3308:3306)容器的 端口映射到本地的端口.

#进入容器
docker attach [containerID] #退出会导致容器终止
docker exec [containerID] #推荐, 退出不会导致容器终止

docker exec -it mysql /bin/bash


```





### 1 mysql

下载镜像: docker pull mysql:5.7

**创建实例并启动**

```shell
docker run -p 3308:3306 --name mysql \
-v /data/mysql/log:/var/log/mysql \
-v /data/mysql/data:/var/lib/mysql \
-v /data/mysql/conf:/etc/mysql \
-e MYSQL_ROOT_PASSWORD=root \
-d mysql:5.7
```

参数说明:

​	-p 3307:3306 将容器的3306 端口映射到主机的3306端口

​	-v /data/mysql/log:/var/log/mysql \  将配置文件夹挂载到主机

​	-v /data/mysql/data:/var/lib/mysql \ 将日志文件挂载到主机

​	-v /data/mysql/conf:/etc/mysql \		将配置文件夹挂载到主机

​	-e MYSQL_ROOT_PASSWORD=root \	初始化root用户的密码



### 2 redis

```shell
mkdir -p /data/redis/conf
touch /data/redis/conf/redis.conf

docker run -p 7001:6379 --name redis \
-v /data/redis/data:/data \
-v /data/redis/conf/redis.conf:/etc/redis/redis.conf \
-d redis redis-server /etc/redis/redis.conf

# 连接redis客户端
docker exec -it redis redis-cli
```



### 3 elasticsearch

```shell
# 下载镜像
docker pull elasticsearch:7.4.2
docker pull kibana:7.4.2

# 创建实例
mkdir -p /data/elasticsearch/config
mkdir -p /data/elasticsearch/data
# 写配置
echo "http.host: 0.0.0.0" >> /data/elasticsearch/config/elasticsearch.properties

# 运行实例 -Xms 限制java占用内存
docker run --name elasticsearch -p 9300:9300 -p 9200:9200 \
-e "discovery.type=single-node" \
-e ES_JAVA_OPT="-Xms64m -Xmx128m" \
-v /data/elasticsearch/config/elasticsearch.yml:/usr/share/elasticsearch/config/elasticsearch.yml \
-v /data/elasticsearch/data:/usr/share/elasticsearch/data \
-v /data/elasticsearch/plugins:/usr/share/elasticsearch/plugins \
-d elasticsearch:7.4.2

```

### 4. Kibana

```shell
docker run --name kibana -e ELASTICSEARCH_HOSTS=http://192.168.88.241:9200 -p 5601:5601 -d kibana:7.4.2
```

### 5. ik分词器

```shell
# 进入es容器内部plugins目录
docker exec -it 容器id /bin/bash
wget ...7.4.2.zip
unzip xxx #解压
rm -rf *.zip
mv elasticsearch/ ik

```







## 技术方案

**SpringCloudAlibaba**

+ Nacos : 注册中心 (服务发现 / 注册)
+ Nacos : 配置中心 (动态配置管理)
+ Ribbon : 负载均衡
+ Feign : 声明式HTTP客户端 (远程调用服务)
+ Sentinel : 服务容错 (限流 , 降级 , 熔断)
+ Gateway : API网关 (webflux 编程模式)
+ Sleuth : 调用链监控
+ Seata : (原 Fescar) 分布式事务解决方案



## nacos

### 注册中心

1. 下载nacos-server 启动 (端口8848)

2. 注册服务pom引入nacos discovery starter

   ```xml
   <dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
   </dependency>
   ```

3. 配置文件中配置 nacos server地址

   spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848

4. 使用@EnableDiscoveryClient 开启服务注册发现功能

5. 用feign测试服务调用



### 配置中心

1. 引入pom

   ```xml
   <dependency>
     <groupId>com.alibaba.cloud</groupId>
     <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
   </dependency>
   ```

2. resources下创建bootstrap.properties 配置文件 配置nacos config元数据

   ```properties
   spring.application.name=gmall-coupon
   spring.cloud.nacos.config.server-addr=127.0.0.1:8848
   ```

3. 完成上述两步后, 应用会从Nacos.config 中获取相应配置, 并添加在Spring Environment 的PropertySources中. 

   ```java
   @Value("${coupon.tom.name:xxx}")
   private String name;
   @Value("${coupon.tom.age:12}")
   private Integer age;
   
   ```

4. 命名空间

   在bootstrap.properties中配置 spring.cloud.nacos.config.namespace=xxxx区别

5. 配置组

   spring.cloud.nacos.config.group=xxx

## Feign

`声明式远程调用`

> Feign 是一个声明式的HTTP客户端. Feign提供了HTTP请求的模板, 通过编写简单的接口和插入注解, 就可定义好HTTP请求的参数, 格式, 地址 等 信息.
>
> Feign 整合了 Ribbon(负载均衡) 和 Hystrix(服务熔断), 可以让我们不再需要显示的使用这2个组件.
>
> SpringCloudFeign 在NetflixFeign 的基础上扩展了 对 SpringMVC注解的支持, 在其实现下, 我们只需创建一个接口并用注解的方式来配置它, 即可完成服务提供方的接口绑定. 简化了SpringCloudRibbon自行封装服务调用客户端的开发量.

1. pom引入

   ```xml
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-openfeign</artifactId>
   </dependency>
   ```

2. App开启标签 @EnableFeignClients

3. 定义调用接口

   ```java
   @FeignClient("gmall-coupon")
   public interface CouponFeignService {
       @RequestMapping("/coupon/coupon/member/list")
       public R membercoupons();
   }
   ```

4. 使用

   ```java
   @Autowired
   CouponFeignService couponFeignService;
   
   R membercoupons = couponFeignService.membercoupons();
   ```

## Gateway

> 网关作为流量的入口,常用功能包括路由转发,权限校验,限流控制 等, 而springcloud gateway 作为springcloud官方推出的第二代网关框架, 取代了zuul

1. 引入pom

   ```xml
   ## gateway 是使用netty + webflux 实现,因此不需要引入web模块
   <dependency>
     <groupId>org.springframework.cloud</groupId>
     <artifactId>spring-cloud-starter-gateway</artifactId>
   </dependency>
   ```

2. 配置文件

   ```yaml
   spring:
     application:
       name: gmall-gateway
     cloud:
       nacos:
         discovery:
           server-addr: mplane.cn:8848
       gateway:
         routes:
           - id: test_route
             uri: https://www.baidu.com
             predicates:
               - Query=url,baidu
           - id: qq_route
             uri: https://www.qq.com
             predicates:
               - Query=url,qq
   ```

   id : 自定义路由id

   uri : 目标服务地址

   predicates : 路由条件

3. 



## swagger2

1. pom依赖

   ```xml
   <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 -->
   <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger2</artifactId>
      <version>2.9.2</version>
   </dependency>
   <!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui -->
   <dependency>
      <groupId>io.springfox</groupId>
      <artifactId>springfox-swagger-ui</artifactId>
      <version>2.9.2</version>
   </dependency>
   ```

   

2. 配置类

   ```java
   @Configuration //配置类
   @EnableSwagger2// 开启Swagger2的自动配置
   public class SwaggerConfig {  
   }
   ```

### 配置swagger

1. swagger实例bean 是Docket, 所以通过配置Docket实例来配置swagger

   ```java
   @Bean //配置docket以配置Swagger具体参数
   public Docket docket() {
      return new Docket(DocumentationType.SWAGGER_2);
   }
   ```

2. 可以通过apiInfo()属性配置文档信息

   ```java
   //配置文档信息
   private ApiInfo apiInfo() {
      Contact contact = new Contact("联系人名字", "http://xxx.xxx.com/联系人访问链接", "联系人邮箱");
      return new ApiInfo(
              "Swagger学习", // 标题
              "学习演示如何配置Swagger", // 描述
              "v1.0", // 版本
              "http://terms.service.url/组织链接", // 组织链接
              contact, // 联系人信息
              "Apach 2.0 许可", // 许可
              "许可链接", // 许可连接
              new ArrayList<>()// 扩展
     );
   }
   ```

3. Docket实例关联上apiInfo()

   ```java
   @Bean
   public Docket docket() {
      return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo());
   }
   ```




### 增强的swagger ui

> knife4j 
>
> https://doc.xiaominfo.com/knife4j/





## elasticsearch

### 初步检索

#### 1. _cat

```shell
GET /_cat/nodes	查看所有节点
GET /_cat/health	查看es健康状况
GET /_cat/master	查看主节点
GET /_cat/indices	查看所有索引 
```



#### 2. 索引一个文档 (保存)

保存一个数据,保存在哪个索引的哪个类型下,制定用哪个唯一标识

```shell
# PUT customer/external/1; 在customer索引下的external类型下保存1号数据为
PUT customer/external/1
{
	"name":"Jack"
}
# PUT POST都可以
# POST 新增, 如果不指定id,会自动生成id.指定id就会修改这个数据,并新增版本号
# PUT 可以新增修改.PUT必须指定id,否则报错

```



#### 3. 查询文档

```shell
GET customer/external/1
结果:
{
	"_index": "customer",	//索引
	"_type": "external",	//类型
	"_id": "1",						//记录id
	"_version": 2,				//版本号
	"_seq_no": 1,					//并发控制字段,每次更新会+1,用来做乐观锁
	"_primary_term": 1,		//同上,主分片重新分配,如重启就会变化
	"found": true,
	"_source": {
		"brandId": 1,
		"name": "华为"
	}
}
-----------------------------
更新携带 ?if_seq_no=0&if_primary_term=1
```



#### 4. 更新文档

```shell
POST customer/external/1/_update
{
	"doc":{
		"name":"tom"
	}
}
或者
POST customer/external/1
{	"name":"tom"}
或者
PUT customer/external/1
{	"name":"tom"}

## POST操作会比较源数据,带_update 的如果数据没变 则不操作
```

#### 5. 删除

```shell
DELETE customer/external/1
DELETE customer
```



#### 6. bulk 批量 API

```shell
POST customer/external/_bulk
{"index":{"_id":"1"}}
{"name":"tom"}
{"index":{"_id":"2"}}
{"name":"jack"}
 
# bulk API按顺序执行所有的action,如果一个单个的动作因任何原因而失败,他将继续处理后面剩余的动作.当bulk API返回时,将提供每个动作的状态
```

### 进阶检索

#### 1. SearchAPI

ES支持两种基本方式检索

+ 一个是通过使用 REST request URI发送搜索参数 (uri + 检索参数)
+ 一个是通过使用 REST request body 发送 (uri + 请求体)

检索信息

+ 一切检索从search开始

  ```shell
  GET bank/_search		#检索bank下所有信息,包括type 和 docs
  GET bank/_search?q=*&sort=account_number:asc #请求方式检索
  # 响应结果解释
  took #执行时间(毫秒)
  time_out #是否超时
  _shards  #多少个分片被搜索了,以及统计了成功/失败的搜索分片
  hits		 #搜索结果
  hits.total	#搜索结果
  hits.hits		#实际的搜索结果数组(默认为前10的文档)
  sort			#结果的排序 key (没有则按 score 排序 )
  score 和 max_score	#相关性得分和最高得分 (全文检索用)
  ```

  

+ uri + 请求体 进行检索

  ```shell
  GET bank/_search
  {
    "query": {
      "match_all": {}
    },
    "sort":[
      {"account_number": {"order": "desc"}}
    ]
  }
  
  ## 
  ```

#### 2. QueryDSL

> Elasticsearch 提供了一个可以执行查询的Json风格的DSL ( domain-specific language 领域特定语言) . 这个被称为 QueryDSL .  

##### 基本用法

```shell
# sort 排序
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "sort": [
    {"age": "asc","balance": "asc"}
  ]
}

# from size 分页
GET bank/_search
{
  "query": {
    "match_all": {}
  },
  "from":0,
  "size":10
}
```

##### match

```shell
# match [匹配查询]
## 基本类型(非字符串),精确匹配
GET bank/_search
{
  "query": {
    "match": {
      "account_number": "20"
    }
  }
}

## 字符串,全文检索
## 默认按score排序
GET bank/_search
{
  "query": {
    "match": {
      "address": "Kings"
    }
  }
}

```

##### match_phrase 

```shell
## 短语匹配
## 将需要匹配的值当成一个整体单词(不分词) 进行检索
## 查出address 中包含 mill road 的所有记录,并给出相关性得分
GET bank/_search
{
  "query": {
    "match_phrase": {
      "address": "mill lane"
    }
  }
}

```

##### multi_match 

```shell
## 多字段匹配
## state 或 address包含 mill
GET bank/_search
{
  "query": {
    "multi_match": {
      "query": "mill",
      "fields":["state","address"]
    }
  }
}
```

##### bool

```shell
## 复合查询
## 复合语句可以合并任何其他查询语句,包括复合语句
## 复合语句之间可以互相嵌套,可以表达非常复杂的逻辑

## must: 必须达到must列举的所有条件
GET /bank/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {"gender": "F"}
        },
        {
          "match": {"address": "mill"}
        }
      ]
    }
  }
}

## must_not : 必须不满足must条件
## should: 不满足也行
```

##### filter

```shell
## 结果过滤
## 并不是所有的查询都需要产生分数,特别是那些仅用于"filtering"(过滤)的文档.为了不计算分数 ES 会自动检查场景并且优化查询的执行.


```

##### term

```shell
## 和match一样 匹配某个属性的值 全文检索字段用match, 其他非text字段匹配用term
```



##### aggregate

```shell
## 执行聚合
## 聚合提供了从数据分组和提取数据的能力. 最简单的聚合方法大致等于SQL GROUP BY和SQL聚合函数. 在ES中,您有执行搜索返回hits(命中结果), 并且同时返回聚合结果, 把一个响应中的所有hits(命中结果)分隔开的能力. 这是非常强大且有效的, 您可以执行查询和多个聚合,并且在一次使用中得到各自的返回结果, 使用一次简洁和简化的API来避免网络往返.

# 搜索address 中包含mill 的所有人的年龄分布以及平均年龄, 但不显示这些人的详情
GET /bank/_search
{
  "query": {
    "match": {
      "address": "mill"
    }
  },
  "aggs": {
    "group_by_state": {
      "terms": {
        "field": "age"
      }
    },
    "avg_age":{
      "avg": { 
        "field": "age"
      }
    }
  }
}

```

#### 3. Mapping

##### 1. 字段类型

```shell
# 核心类型
字符串(string) 
		text,keyword
数字类型	
		(Num)long,integer,short,byte,double,float,half_float,scaled_float
日期类型(Date) 
		date
布尔类型(Boolean)
		boolean
二进制类型(binary)
		binary

# 复合类型
数组类型(Array)
		Array 支持不针对特定的类型
对象类型(Object)
		object用于单JSON对象
嵌套类型(Nested)
		nested用于JSON对象
		
# 地理类型(GEO)
地理坐标(Geo-point)
		geo_point 用于描述经纬度坐标
地理图形(Geo-shape)
		geo_shape 用于秒速复杂形状,如多边形
	
# 特定类型
IP类型
		ip 用于描述ipv4 ipv6
不全类型(Completion)
		completion 提供自动完成提示
令牌计数类型(Token count)
		token_count用于统计字符串中的词条数量
附件类型(attachment)
		参考 mapper-attachements 插件,支持将附件如 Microsoft Office格式,Epub ..索引为 attachment 数据类型

抽取类型(Percolator)
		接受特点领域语言(query-dsl)的查询

# 多字段
通常用于为不同目的用不同的方法索引一个字段. 例如:string字段可以映射为一个text字段用于全文检索. 同样可以映射为一个keyword 字段用于排序和聚合. 另外, 你可以使用standard analyzer, English analyzer, french analyzer 来索引一个text字段
这就是 muti-fields的目的. 大多数的数据类型通过fields参数来支持 muti-fields
```

##### 2. 映射

Mapping 是用来定义一个文档(document) , 以及它所包含的属性(field) 是如何存储和索引的. 比如, 使用mapping来定义 :

+ 哪些字符串属性应该被看做全文本属性
+ 哪些属性包含数字,日期或者地理位置
+ 文档中的所有属性是否都能被索引 ( _all 配置 )
+ 日期的格式
+ 自定义映射规则来执行动态添加属性
+ 查看mapping 信息
+ 修改mapping 信息

 ```shell
# 创建映射
PUT bank
{
  "mappings":{
    "properties":{
      "age":{"type":"integer"},
      "email":{"type":"keyword"},
      "name":{"type":"text"}
    }
  }
}

# 添加新的字段映射
PUT bank/_mapping
{
  "properties":{
    "employee-id":{"type":"keyword","index":false}
  }
}

# 对于已经存在的映射字段,不能更新. 必须创建新的索引进行数据迁移

# 数据迁移
## 先创建出 new_twitter 的正确映射. 然后使用如下方式迁移
POST _reindex
{
  "source": {
    "index": "twitter"
  },
  "dest": {
    "index": "new_twitter"
  }
}

 ```

#### 4. 分词

> 一个tokenizer ( 分词器 ) 接收一个字符流, 将之分割为独立的 tokens ( 词元, 通常是独立的单词 ), 然后输出 tokens 流.
>
> 例如, whitespace 遇到空白字符时分割文本. 它会将文本 "Quick brown fox!"分割为[Quick , brown , fox!].
>
> 该tokenizer 还负责记录各个term(词条) 的顺序或 position (用于phrase短语 和 Word proximity 词近邻查询), 以及term 所代表的原始 word 的start 和 end 的character offsets(字符偏移量) .
>
> ES提供了很多内置的分词器, 可以用来构建custom analyzers(自定义分词器)

测试分词器

```shell
POST _analyze
{
  "analyzer": "ik_smart",
  "text": "我是一个程序员!"
}
```



### 整合springboot

**elasticsearch-rest-high-level-client** 官方推荐client

```xml
#pom
<!--es rest client-->
<properties>
  <elasticsearch.version>7.4.2</elasticsearch.version>
</properties>

<dependency>
  <groupId>org.elasticsearch.client</groupId>
  <artifactId>elasticsearch-rest-high-level-client</artifactId>
  <version>7.4.2</version>
</dependency>
```

```java
// 配置文件
@Configuration
public class ESconfig {
    @Bean
    public RestHighLevelClient restHighLevelClient(){
        RestClientBuilder builder = RestClient.builder(new HttpHost("127.0.0.1", 9200, "http"));
        return new RestHighLevelClient(builder);
    }
}
```



### 商品spu es 存储模型

```json
## 设置mapping
PUT product
{
  "mappings": {
    "properties": {
      "skuId":{"type":"long"},
      "spuId":{"type":"keyword"},
      "skuTitle":{"type":"text","analyzer": "ik_smart"},
      "skuPrice":{"type":"keyword"},
      "skuImg":{"type":"keyword","index": false,"doc_values": false},
      "saleCount":{"type":"long"},
      "hasStock":{"type":"boolean"},
      "hotScore":{"type":"long"},
      "brandId":{"type":"long"},
      "categoryId":{"type":"long"},
      "brandName":{"type":"keyword","index": false,"doc_values": false},
      "brandImg":{"type":"keyword","index": false,"doc_values": false},
      "categoryName":{"type":"keyword","index": false,"doc_values": false},
      "attrs":{
        "type": "nested",
        "properties": {
          "attrId":{"type":"long"},
          "attrName":{"type":"keyword","index": false,"doc_values": false},
          "attrValue":{"type":"keyword"}
        }
      }
    }
  }
}
```





## 配置nginx

```conf
# 域名 指向网关
http {
	#上游服务器
	upstream mp{
		server 127.0.0.1:88;
	}
}

server{
	listen	80;
	server_name	mp.com;
	location / {
		proxy_set_header Host $host;
		proxy_pass	http://mp.com;
	}
}
```



## 异步编程 CompletbaleFutue

 Future是Java 5添加的类，用来描述一个异步计算的结果。你可以使用`isDone`方法检查计算是否完成，或者使用`get`阻塞住调用线程，直到计算完成返回结果，你也可以使用`cancel`方法停止任务的执行。

虽然`Future`以及相关使用方法提供了异步执行任务的能力，但是对于结果的获取却是很不方便，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们的异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时地得到计算结果，为什么不能用观察者设计模式当计算结果完成及时通知监听者呢？

很多语言，比如Node.js，采用回调的方式实现异步编程。Java的一些框架，比如Netty，自己扩展了Java的 `Future`接口，提供了`addListener`等多个扩展方法；Google guava也提供了通用的扩展Future；Scala也提供了简单易用且功能强大的Future/Promise异步编程模式。

作为正统的Java类库，是不是应该做点什么，加强一下自身库的功能呢？

在Java 8中, 新增加了一个包含50个方法左右的类: CompletableFuture，提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法。

CompletableFuture类实现了Future接口，所以你还是可以像以前一样通过`get`方法阻塞或者轮询的方式获得结果，但是这种方式不推荐使用。

CompletableFuture和FutureTask同属于Future接口的实现类，都可以获取线程的执行结果。

![1568552614487](pic/1568552614487.png)



### 1.   创建异步对象

CompletableFuture 提供了四个静态方法来创建一个异步操作。

```java
static CompletableFuture<Void> runAsync(Runnable runnable)
public static CompletableFuture<Void> runAsync(Runnable runnable, Executor executor)
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)
public static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier, Executor executor)
```

**没有指定Executor的方法会使用ForkJoinPool.commonPool() 作为它的线程池执行异步代码**。如果指定线程池，则使用指定的线程池运行。以下所有的方法都类同。

- runAsync方法不支持返回值。
- supplyAsync可以支持返回值。



### 2.   计算完成时回调方法

当CompletableFuture的计算结果完成，或者抛出异常的时候，可以执行特定的Action。主要是下面的方法：

```java
public CompletableFuture<T> whenComplete(BiConsumer<? super T,? super Throwable> action);
public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action);
public CompletableFuture<T> whenCompleteAsync(BiConsumer<? super T,? super Throwable> action, Executor executor);

public CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn);
```

whenComplete可以处理正常和异常的计算结果，exceptionally处理异常情况。BiConsumer<? super T,? super Throwable>可以定义处理业务

whenComplete 和 whenCompleteAsync 的区别：
		whenComplete：是执行当前任务的线程执行继续执行 whenComplete 的任务。
		whenCompleteAsync：是执行把 whenCompleteAsync 这个任务继续提交给线程池来进行执行。

**方法不以Async结尾，意味着Action使用相同的线程执行，而Async可能会使用其他线程执行（如果是使用相同的线程池，也可能会被同一个线程选中执行）**



代码示例：

```java
public class CompletableFutureDemo {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture future = CompletableFuture.supplyAsync(new Supplier<Object>() {
            @Override
            public Object get() {
                System.out.println(Thread.currentThread().getName() + "\t completableFuture");
                int i = 10 / 0;
                return 1024;
            }
        }).whenComplete(new BiConsumer<Object, Throwable>() {
            @Override
            public void accept(Object o, Throwable throwable) {
                System.out.println("-------o=" + o.toString());
                System.out.println("-------throwable=" + throwable);
            }
        }).exceptionally(new Function<Throwable, Object>() {
            @Override
            public Object apply(Throwable throwable) {
                System.out.println("throwable=" + throwable);
                return 6666;
            }
        });
        System.out.println(future.get());
    }
}


CompletableFuture.supplyAsync(()->{
            System.out.println("run supplyAsync");
            int i = 1 / 0;
            return "hello async";
        }).whenComplete((t,u)->{
            System.out.println("t -> "+t);
            System.out.println("u -> "+u);
        }).exceptionally((e)->{
            System.out.println("e -> "+e);
            return e.toString();
        });
```



### 3.  handle 方法

handle 是执行**任务完成时**对结果的处理。
handle 是在任务完成后再执行，还可以处理异常的任务。

```java
public <U> CompletionStage<U> handle(BiFunction<? super T, Throwable, ? extends U> fn);
public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn);
public <U> CompletionStage<U> handleAsync(BiFunction<? super T, Throwable, ? extends U> fn,Executor executor);
```



### 4.   线程串行化方法

thenApply 方法：当一个线程依赖另一个线程时，获取上一个任务返回的结果，并返回当前任务的返回值。

thenAccept方法：消费处理结果。接收任务的处理结果，并消费处理，无返回结果。

thenRun方法：只要上面的任务执行完成，就开始执行thenRun，只是处理完任务后，执行 thenRun的后续操作

带有Async默认是异步执行的。这里所谓的异步指的是不在当前线程内执行。

```java
public <U> CompletableFuture<U> thenApply(Function<? super T,? extends U> fn)
public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn)
public <U> CompletableFuture<U> thenApplyAsync(Function<? super T,? extends U> fn, Executor executor)

public CompletionStage<Void> thenAccept(Consumer<? super T> action);
public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action);
public CompletionStage<Void> thenAcceptAsync(Consumer<? super T> action,Executor executor);

public CompletionStage<Void> thenRun(Runnable action);
public CompletionStage<Void> thenRunAsync(Runnable action);
public CompletionStage<Void> thenRunAsync(Runnable action,Executor executor);
```

Function<? super T,? extends U>
		T：上一个任务返回结果的类型
		U：当前任务的返回值类型

代码演示：

```java
public static void main(String[] args) throws ExecutionException, InterruptedException {
    CompletableFuture<Integer> future = CompletableFuture.supplyAsync(new Supplier<Integer>() {
        @Override
        public Integer get() {
            System.out.println(Thread.currentThread().getName() + "\t completableFuture");
            //int i = 10 / 0;
            return 1024;
        }
    }).thenApply(new Function<Integer, Integer>() {
        @Override
        public Integer apply(Integer o) {
            System.out.println("thenApply方法，上次返回结果：" + o);
            return  o * 2;
        }
    }).whenComplete(new BiConsumer<Integer, Throwable>() {
        @Override
        public void accept(Integer o, Throwable throwable) {
            System.out.println("-------o=" + o);
            System.out.println("-------throwable=" + throwable);
        }
    }).exceptionally(new Function<Throwable, Integer>() {
        @Override
        public Integer apply(Throwable throwable) {
            System.out.println("throwable=" + throwable);
            return 6666;
        }
    }).handle(new BiFunction<Integer, Throwable, Integer>() {
        @Override
        public Integer apply(Integer integer, Throwable throwable) {
            System.out.println("handle o=" + integer);
            System.out.println("handle throwable=" + throwable);
            return 8888;
        }
    });
    System.out.println(future.get());
}
```



### 5. 两任务组合 - 都要完成

两个任务必须都完成，触发该任务。

thenCombine：组合两个future，获取两个future的返回结果，并返回当前任务的返回值

thenAcceptBoth：组合两个future，获取两个future任务的返回结果，然后处理任务，没有返回值。

runAfterBoth：组合两个future，不需要获取future的结果，只需两个future处理完任务后，处理该任务。

```java
public <U,V> CompletableFuture<V> thenCombine(
    CompletionStage<? extends U> other,
    BiFunction<? super T,? super U,? extends V> fn);

public <U,V> CompletableFuture<V> thenCombineAsync(
    CompletionStage<? extends U> other,
    BiFunction<? super T,? super U,? extends V> fn);

public <U,V> CompletableFuture<V> thenCombineAsync(
    CompletionStage<? extends U> other,
    BiFunction<? super T,? super U,? extends V> fn, Executor executor);
    

public <U> CompletableFuture<Void> thenAcceptBoth(
    CompletionStage<? extends U> other,
    BiConsumer<? super T, ? super U> action);

public <U> CompletableFuture<Void> thenAcceptBothAsync(
    CompletionStage<? extends U> other,
    BiConsumer<? super T, ? super U> action);

public <U> CompletableFuture<Void> thenAcceptBothAsync(
    CompletionStage<? extends U> other,
    BiConsumer<? super T, ? super U> action, Executor executor);


public CompletableFuture<Void> runAfterBoth(CompletionStage<?> other,
                                            Runnable action);

public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
                                                 Runnable action);

public CompletableFuture<Void> runAfterBothAsync(CompletionStage<?> other,
                                                 Runnable action,
                                                 Executor executor);
```

测试案例：

```java
public static void main(String[] args) {
    CompletableFuture.supplyAsync(() -> {
        return "hello";
    }).thenApplyAsync(t -> {
        return t + " world!";
    }).thenCombineAsync(CompletableFuture.completedFuture(" CompletableFuture"), (t, u) -> {
        return t + u;
    }).whenComplete((t, u) -> {
        System.out.println(t);
    });
}
```

输出：hello world! CompletableFuture



### 6.   两任务组合 - 一个完成

当两个任务中，任意一个future任务完成的时候，执行任务。

applyToEither：两个任务有一个执行完成，获取它的返回值，处理任务并有新的返回值。

acceptEither：两个任务有一个执行完成，获取它的返回值，处理任务，没有新的返回值。

runAfterEither：两个任务有一个执行完成，不需要获取future的结果，处理任务，也没有返回值。

```java
public <U> CompletableFuture<U> applyToEither(
    CompletionStage<? extends T> other, Function<? super T, U> fn);

public <U> CompletableFuture<U> applyToEitherAsync(
    CompletionStage<? extends T> other, Function<? super T, U> fn);

public <U> CompletableFuture<U> applyToEitherAsync(
    CompletionStage<? extends T> other, Function<? super T, U> fn,
    Executor executor);

public CompletableFuture<Void> acceptEither(
    CompletionStage<? extends T> other, Consumer<? super T> action);

public CompletableFuture<Void> acceptEitherAsync(
    CompletionStage<? extends T> other, Consumer<? super T> action);

public CompletableFuture<Void> acceptEitherAsync(
    CompletionStage<? extends T> other, Consumer<? super T> action,
    Executor executor);

public CompletableFuture<Void> runAfterEither(CompletionStage<?> other,
                                              Runnable action);

public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
                                                   Runnable action);

public CompletableFuture<Void> runAfterEitherAsync(CompletionStage<?> other,
                                                   Runnable action,
                                                   Executor executor);
```



### 7.   多任务组合

```java
public static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs);

public static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs);
```

allOf：等待所有任务完成

anyOf：只要有一个任务完成



```java
public static void main(String[] args) {
    List<CompletableFuture> futures = Arrays.asList(CompletableFuture.completedFuture("hello"),
                                                    CompletableFuture.completedFuture(" world!"),
                                                    CompletableFuture.completedFuture(" hello"),
                                                    CompletableFuture.completedFuture("java!"));
    final CompletableFuture<Void> allCompleted = CompletableFuture.allOf(futures.toArray(new CompletableFuture[]{}));
    allCompleted.thenRun(() -> {
        futures.stream().forEach(future -> {
            try {
                System.out.println("get future at:"+System.currentTimeMillis()+", result:"+future.get());
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        });
    });
}
```

测试结果：

```
get future at:1568892339473, result:hello
get future at:1568892339473, result: world!
get future at:1568892339473, result: hello
get future at:1568892339473, result:java!
```

几乎同时完成任务！



### 8.   优化商品详情页

```java
@Service
public class ItemServiceImpl implements ItemService {

    @Autowired
    private GmallPmsFeign pmsFeign;

    @Autowired
    private GmallSmsFeign smsFeign;

    @Autowired
    private GmallWmsFeign wmsFeign;

    @Autowired
    private ThreadPoolExecutor threadPoolExecutor;


    @Override
    public ItemVO loadData(Long skuId) throws ExecutionException, InterruptedException {

        ItemVO itemVO = new ItemVO();

        // 1. 获取sku的基本信息
        // 后续获取sku的促销信息、spu的销售属性和spu详情信息（需要sku中的spuId）都需要skuInfoEntity
        // supplyAsync有返回值
        // runAsync无返回值
        // 所以这里需要使用supplyAsync
        CompletableFuture<SkuInfoEntity> skuFuture = CompletableFuture.supplyAsync(() -> {
            Resp<SkuInfoEntity> skuInfoEntityResp = this.pmsFeign.querySkuById(skuId);
            SkuInfoEntity skuInfoEntity = skuInfoEntityResp.getData();
            if (skuInfoEntity != null) {
                BeanUtils.copyProperties(skuInfoEntity, itemVO);
            }
            return skuInfoEntity;
        }, threadPoolExecutor);


        // 2. 获取sku的图片信息
        CompletableFuture<Void> skuImageFuture = CompletableFuture.runAsync(() -> {
            Resp<List<SkuImagesEntity>> listResp = this.pmsFeign.queryImagesBySkuId(skuId);
            List<SkuImagesEntity> images = listResp.getData();
            if (!CollectionUtils.isEmpty(images)) {
                List<String> imageUrls = images.stream().map(image -> image.getImgUrl()).collect(Collectors.toList());
                itemVO.setPics(imageUrls);
            }
        }, threadPoolExecutor);


        // 3. 获取sku的促销信息 TODO

        // 4. 获取spu的所有销售属性
        // thenAcceptAsync：有参数，无返回
        // thenApplyAsync: 有参数，有返回
        // 后续spu详情也需要skuInfoEntity中的spuId，所以这里使用thenApplyAsync
        CompletableFuture<SkuInfoEntity> spuFuture = skuFuture.thenApplyAsync(skuInfoEntity -> {
            Resp<List<SkuSaleAttrValueEntity>> skuSaleAttrValueResp = this.pmsFeign.querySkuSaleAttrValueBySpuId(skuInfoEntity.getSpuId());
            List<SkuSaleAttrValueEntity> skuSaleAttrValueEntities = skuSaleAttrValueResp.getData();
            itemVO.setSaleAttrs(skuSaleAttrValueEntities);
            return skuInfoEntity;
        }, threadPoolExecutor);

        // 5. 获取规格参数组及组下的规格参数 TODO

        // 6. spu详情 TODO

        CompletableFuture<Void> future = CompletableFuture.allOf(skuFuture, skuImageFuture, spuFuture);
        // 阻塞主进程，等待子进程全部执行完毕！
        future.get();

        return itemVO;
    }


}
```



























