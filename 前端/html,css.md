### html

#### 实体,特殊符号

```html
&nbsp; 空格
&gt; 大于号
&lt; 小于号
&copy; 版权符号
```

#### meta标签

```html
charset 指定网页的字符集
name 指定的数据的名称
content 指定的数据的内容
keywords 表示网站的关键字，可以同时指定多个关键字，关键字间使用,隔开

<meta name="Keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"/>

<meta name="keywords" content="网购,网上购物,在线购物,网购网站,网购商城,购物网站,网购中心,购物中心,卓越,亚马逊,卓越亚马逊,亚马逊中国,joyo,amazon">
                    
description 用于指定网站的描述
<meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"/>
网站的描述会显示在搜索引擎的搜索的结果中

title标签的内容会作为搜索结果的超链接上的文字显示    

将页面重定向到另一个网站
<meta http-equiv="refresh" content="3;url=https://www.mozilla.org"> 

```

#### 语义化标签

```html
p 段落
h1 - h6	标题

hgroup
 <hgroup>
   <h1>回乡偶书二首</h1>
   <h2>其一</h2>
</hgroup>

em, 加重 (斜体)
strong, 强调 ,(粗体)
blockquote, 长引用 ()
q, 短引用 (双引号)

br,换行

```



#### 布局标签

```html
p里面不能放块元素

header 表示网页的头部
main 表示网页的主体部分(一个页面中只会有一个main)
footer 表示网页的底部
nav 表示网页中的导航
aside 和主体相关的其他内容（侧边栏）
article 表示一个独立的文章
section 表示一个独立的区块，上边的标签都不能表示时使用section

div 没有语义，就用来表示一个区块，目前来讲div还是我们主要的布局元素
span 行内元素，没有任何的语义，一般用于在网页中选中文字
```

#### 列表

```html
列表（list）
  1、铅笔
  2、尺子
  3、橡皮

在html中也可以创建列表，html列表一共有三种：
  1、有序列表
  2、无序列表
  3、定义列表

无序列表，使用 ol 标签来创建无序列表
	使用 li 表示列表项  

无序列表，使用 ul 标签来创建无序列表
	使用 li 表示列表项

定义列表，使用dl标签来创建一个定义列表
  使用dt来表示定义的内容
  使用dd来对内容进行解释说明

列表之间可以互相嵌套
```

#### 超链接

```html
使用 a 标签来定义超链接
  属性：
  href 指定跳转的目标路径
  - 值可以是一个外部网站的地址
  - 也可以写一个内部页面的地址

超链接是也是一个行内元素，在a标签中可以嵌套除它自身外的任何元素

<a href="https://www.baidu.com">超链接</a>

target属性，用来指定超链接打开的位置
	可选值：
    _self 默认值 在当前页面中打开超链接
    _blank 在一个新的要么中打开超链接


<a href="#p3">去第三个自然段</a> 
id=p3

可以使用 javascript:; 来作为href的属性，此时点击这个超链接什么也不会发生 -
<a href="javascript:;">这是一个新的超链接</a>

可以直接将超链接的href属性设置为#，这样点击超链接以后
页面不会发生跳转，而是转到当前页面的顶部的位置
```



### css

#### 选择器

##### 复合选择器

```css
  交集选择器	语法：选择器1选择器2选择器3选择器n{}
  div.red{
    font-size: 30px;
  }
	
	并集选择器	语法：选择器1,选择器2,选择器3,选择器n{}
	h1, span{
    color: green
	}
	
```

##### 关系选择器

```css
父元素
- 直接包含子元素的元素叫做父元素
子元素
- 直接被父元素包含的元素是子元素
祖先元素
- 直接或间接包含后代元素的元素叫做祖先元素
- 一个元素的父元素也是它的祖先元素
后代元素
- 直接或间接被祖先元素包含的元素叫做后代元素
- 子元素也是后代元素
兄弟元素
- 拥有相同父元素的元素是兄弟元素


子元素选择器 
语法 : 父元素 > 子元素
div.box > span{
	color: orange;
} 

后代元素选择器
语法：祖先 后代
div span{
	color: skyblue
} 

兄弟选择器
下一个 : 前一个 + 下一个
后面所有 : 前一个 ~ 下一个
```



##### 属性选择器

```css
[属性名] 选择含有指定属性的元素
[属性名 = 属性值] 选择含有指定属性和属性值的元素
[属性名 ^= 属性值] 选择属性值以指定值开头的元素
[属性名 $= 属性值] 选择属性值以指定值结尾的元素
[属性名 *= 属性值] 选择属性值中含有某值的元素的元素


/* p[title]{ */
/* p[title=abc]{ */
/* p[title^=abc]{ */
/* p[title$=abc]{ */

p[title*=e]{
  color: orange;
}

<p title="abc">少小离家老大回</p>
<p title="abcdef">乡音无改鬓毛衰</p>
<p title="helloabc">儿童相见不相识</p>
<p>笑问客从何处来</p>
<p>秋水共长天一色</p>
<p>落霞与孤鹜齐飞</p>

```



##### 伪类选择器

```css
一个:开头
:first-child 第一个子元素
:last-child 最后一个子元素
:nth-child() 选中第n个子元素
特殊值：
n 第n个 n的范围0到正无穷
2n 或 even 表示选中偶数位的元素
2n+1 或 odd 表示选中奇数位的元素

- 以上这些伪类都是根据所有的子元素进行排序

:first-of-type
:last-of-type
:nth-of-type() (跟nth-child 的区别是 不收其他元素影响)
- 这几个伪类的功能和上述的类似，不通点是他们是在同类型元素中进行排序


a标签的伪类:
:link 用来表示没访问过的链接（正常的链接）
:visited 用来表示访问过的链接
	由于隐私的原因，所以visited这个伪类只能修改链接的颜色
:hover 用来表示鼠标移入的状态
:active 用来表示鼠标点击
```



##### 伪元素选择器

```css
伪元素，表示页面中一些特殊的并不真实的存在的元素（特殊的位置）
伪元素使用 (两个):: 开头

::first-letter 表示第一个字母
::first-line 表示第一行
::selection 表示选中的内容
::before 元素的开始 
::after 元素的最后
	- before 和 after 必须结合content属性来使用

div::before{
  content: 'abc';
  color: red;
}

div::after{
  content: 'haha';
  color: blue;
} 
```

##### 继承

```css
样式的继承，我们为一个元素设置的样式同时也会应用到它的后代元素上

继承是发生在祖先后后代之间的

继承的设计是为了方便我们的开发，
  利用继承我们可以将一些通用的样式统一设置到共同的祖先元素上，
  这样只需设置一次即可让所有的元素都具有该样式

注意：并不是所有的样式都会被继承：
	比如 背景相关的，布局相关等的这些样式都不会被继承。


样式的冲突
	- 当我们通过不同的选择器，选中相同的元素，并且为相同的样式设置不同的值时，此时就发生了样式的冲突。

发生样式冲突时，应用哪个样式由选择器的权重（优先级）决定

选择器的权重
  内联样式        1,0,0,0
  id选择器        0,1,0,0
  类和伪类选择器   0,0,1,0
  元素选择器       0,0,0,1
  通配选择器       0,0,0,0
  继承的样式       没有优先级

比较优先级时，需要将所有的选择器的优先级进行相加计算，最后优先级越高，则越优先显示（分组选择器是单独计算的）,
选择器的累加不会超过其最大的数量级，类选择器在高也不会超过id选择器
如果优先级计算后相同，此时则优先使用靠下的样式

可以在某一个样式的后边添加 !important ，则此时该样式会获取到最高的优先级，甚至超过内联样式，
	注意：在开发中这个玩意一定要慎用！
```

##### 单位

```css
像素
  - 屏幕（显示器）实际上是由一个一个的小点点构成的
  - 不同屏幕的像素大小是不同的，像素越小的屏幕显示的效果越清晰
  - 所以同样的200px在不同的设备下显示效果不一样

百分比
  - 也可以将属性值设置为相对于 其父元素 属性的百分比
  - 设置百分比可以使子元素跟随父元素的改变而改变

em
  - em是相对于元素的字体大小来计算的
  - 1em = 1font-size
  - em会根据字体大小的改变而改变

rem
	- rem是相对于根元素的字体大小来计算
```

##### 颜色

```css
在CSS中可以直接使用颜色名来设置各种颜色
  比如：red、orange、yellow、blue、green ... ...
	但是在css中直接使用颜色名是非常的不方便
	background-color: red;


RGB值：
  - RGB通过三种颜色的不同浓度来调配出不同的颜色
  - R red，G green ，B blue
  - 每一种颜色的范围在 0 - 255 (0% - 100%) 之间
  - 语法：RGB(红色,绿色,蓝色)
RGBA:
  - 就是在rgb的基础上增加了一个a表示不透明度
  - 需要四个值，前三个和rgb一样，第四个表示不透明度
  1表示完全不透明   0表示完全透明  .5半透明

	background-color: rgb(255, 0, 0);
  background-color: rgb(0, 255, 0);
  background-color: rgb(0, 0, 255);
  background-color: rgb(255,255,255);
  background-color: rgb(106,153,85);
  background-color: rgba(106,153,85,.5);

十六进制的RGB值：
  - 语法：#红色绿色蓝色
  - 颜色浓度通过 00-ff
  - 如果颜色两位两位重复可以进行简写  
  #aabbcc --> #abc

  background-color: #ff0000;
  background-color: #ffff00;
  background-color: #ff0;
  background-color: #bbffaa;
  background-color: #9CDCFE;

HSL值 HSLA值
  H 色相(0 - 360)
  S 饱和度，颜色的浓度 0% - 100%
  L 亮度，颜色的亮度 0% - 100%
	background-color: hsla(98, 48%, 40%, 0.658);
```

#### 布局

> 文档流
>
> - 网页是一个多层的结构，一层摞着一层
> - 通过CSS可以分别为每一层来设置样式
> - 作为用户来讲只能看到最顶上一层
> - 这些层中，最底下的一层称为文档流，文档流是网页的基础
>                 我们所创建的元素默认都是在文档流中进行排列
> - 对于我们来元素主要有两个状态
>                 在文档流中
>                 不在文档流中（脱离文档流）
>
> 
>
> 块元素
>
>    - 块元素会在页面中独占一行(自上向下垂直排列)
>    - 默认宽度是父元素的全部（会把父元素撑满）
>    - 默认高度是被内容撑开（子元素）
>
> 行内元素
>
> - 行内元素不会独占页面的一行，只占自身的大小
> - 行内元素在页面中左向右水平排列，如果一行之中不能容纳下所有的行内元素
>     则元素会换到第二行继续自左向右排列（书写习惯一致）
> - 行内元素的默认宽度和高度都是被内容撑开

#### 盒子模型

> - CSS将页面中的所有元素都设置为了一个矩形的盒子
> - 将元素设置为矩形的盒子后，对页面的布局就变成将不同的盒子摆放到不同的位置
> - 每一个盒子都由一下几个部分组成：
>                 内容区（content）
>                 内边距（padding）
>                 边框（border）
>                 外边距（margin）



```css
.box1{
    /* 
      内容区（content），元素中的所有的子元素和文本内容都在内容区中排列  
      内容区的大小由width 和 height两个属性来设置
      width 设置内容区的宽度
      height 设置内容区的高度          
    */
    width: 200px;
    height: 200px;
    background-color: #bfa;

    /* 
      边框（border）边框属于盒子边缘，边框里边属于盒子内部，出了边框都是盒子的外部
      边框的大小会影响到整个盒子的大小
      要设置边框，需要至少设置三个样式：
      边框的宽度 border-width
      边框的颜色 border-color
      边框的样式 border-style
    */
    border-width: 10px;
    border-color: red;
    border-style: solid;
}
```

##### 边框

```css
边框的宽度 border-width
边框的颜色 border-color
边框的样式 border-style

border-width: 10px; 
	默认值，一般都是 3个像素
border-width可以用来指定四个方向的边框的宽度值的情况
  四个值：上 右 下 左
  三个值：上 左右 下
  两个值：上下 左右
  一个值：上下左右

除了border-width还有一组 border-xxx-width
	xxx可以是 top right bottom left
	用来单独指定某一个边的宽度

border-width: 10px;
border-top-width: 10px;
border-left-width: 30px; 

border-color用来指定边框的颜色，同样可以分别指定四个边的边框
	规则和border-width一样

border-style 指定边框的样式
  solid 表示实线
  dotted 点状虚线
  dashed 虚线
  double 双线

border-style的默认值是none 表示没有边框
```

##### 内边距

```css
内边距（padding）
  - 内容区和边框之间的距离是内边距
  - 一共有四个方向的内边距：
  padding-top
  padding-right
  padding-bottom
  padding-left

  - 内边距的设置会影响到盒子的大小
  - 背景颜色会延伸到内边距上

一共盒子的可见框的大小，由内容区 内边距 和 边框共同决定，
	所以在计算盒子大小时，需要将这三个区域加到一起计算
```

##### 外边距

```css
- 外边距不会影响盒子可见框的大小
- 但是外边距会影响盒子的位置
- 一共有四个方向的外边距：

margin-top
	- 上外边距，设置一个正值，元素会向下移动
margin-right
	- 默认情况下设置margin-right不会产生任何效果
margin-bottom
	- 下外边距，设置一个正值，其下边的元素会向下移动
margin-left
	- 左外边距，设置一个正值，元素会向右移动

- margin也可以设置负值，如果是负值则元素会向相反的方向移动

- 元素在页面中是按照自左向右的顺序排列的，
  所以默认情况下如果我们设置的左和上外边距则会移动元素自身
	而设置下和右外边距会移动其他元素

- margin的简写属性
	margin 可以同时设置四个方向的外边距 ，用法和padding一样

- margin会影响到盒子实际占用空间
```



##### ==水平方向布局==

> 元素在其父元素中水平方向的位置由以下几个属性共同决定“
>                         margin-left
>                         border-left
>                         padding-left
>                         width
>                         padding-right
>                         border-right
>                         margin-right

一个元素在其父元素中，水平布局必须要满足以下的等式 : 
margin-left + border-lef + padding-lef t +  ==width==  +  padding-right  +  border-right  +  margin-right = ==其父元素内容区的宽度== （必须满足）

以上等式必须满足，如果相加结果使等式不成立，则称为过度约束，则等式会自动调整
   - 调整的情况：
        果这七个值中没有为 auto 的情况，则浏览器会自动调整 ==margin-right== 值以使等式满足

- 这七个值中有三个值和设置为auto
         width
         margin-left
         maring-right

     如果某个值为auto，则会自动调整为auto的那个值以使等式成立

- 如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0

- 如果将三个值都设置为auto，则外边距都是0，宽度最大

-  如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值
            ==所以我们经常利用这个特点来使一个元素在其父元素中水平居中==

##### 垂直方向布局

子元素是在父元素的内容区中排列的，
        如果子元素的大小超过了父元素，则子元素会从父元素中溢出
        使用 ==overflow== 属性来设置父元素如何处理溢出的子元素

    可选值：
        visible，默认值 子元素会从父元素中溢出，在父元素外部的位置显示
        hidden 溢出内容将会被裁剪不会显示
        scroll 生成两个滚动条，通过滚动条来查看完整的内容
        auto 根据需要生成滚动条
##### 外边距的折叠

垂直外边距的重叠（折叠）
   - 相邻的垂直方向外边距会发生重叠现象
        外边距会取两者之间的较大值（两者都是正值）

        特殊情况：
        如果相邻的外边距一正一负，则取两者的和
        如果相邻的外边距都是负值，则取两者中绝对值较大的

 - 兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理


- 父子元素间相邻外边距，==子元素的会传递给父元素（上外边距)==

     父子外边距的折叠会影响到页面的布局，必须要进行处理

##### 行内元素的盒子模型

- 行内元素不支持设置宽度和高度
- 行内元素可以设置padding，但是垂直方向padding不会影响页面的布局
- 行内元素可以设置border，垂直方向的border不会影响页面的布局
- 行内元素可以设置margin，垂直方向的margin不会影响布局

**display** 用来设置元素显示的类型
                    可选值：
                        inline 将元素设置为行内元素
                        block 将元素设置为块元素
                        ==inline-block== 将元素设置为行内块元素 
                                行内块，既可以设置宽度和高度又不会独占一行
                        table 将元素设置为一个表格
                        none 元素不在页面中显示

**visibility** 用来设置元素的显示状态
   	可选值：
		visible 默认值，元素在页面中正常显示
        hidden 元素在页面中隐藏 不显示，==但是依然占据页面的位置==

##### 盒子的尺寸

默认情况下，盒子可见框的大小由==内容区、内边距 和 边框==共同决定

box-sizing 用来设置盒子尺寸的计算方式（设置width和height的作用）
可选值：
		content-box 默认值，宽度和高度用来设置内容区的大小
		border-box 宽度和高度用来设置整个盒子可见框的大小
		width 和 height 指的是内容区 和 内边距 和 边框的总大小

##### 轮廓和圆角

==box-shadow== 用来设置==元素的阴影效果==，**阴影不会影响页面布局 **
                第一个值 水平偏移量 设置阴影的水平位置 正值向右移动 负值向左移动
                第二个值 垂直偏移量 设置阴影的水平位置 正值向下移动 负值向上移动
                第三个值 阴影的模糊半径
                第四个值 阴影的颜色

​				box-shadow: 0px 0px 50px rgba(0, 0, 0, .3) ; 

==outline== 用来设置==元素的轮廓线==，用法和border一模一样
                轮廓和边框不同的点，就是**轮廓不会影响到可见框的大小 **

 ==border-radius==: 用来设置==圆角== 圆角设置的圆的半径大小

            /* border-top-left-radius:  */
            /* border-top-right-radius */
            /* border-bottom-left-radius:  */
            /* border-bottom-right-radius:  */
            /* border-top-left-radius:50px 100px; */
    
            /* 
                border-radius 可以分别指定四个角的圆角
                    四个值 左上 右上 右下 左下
                    三个值 左上 右上/左下 右下 
                    两个个值 左上/右下 右上/左下  
              */
            /* border-radius: 20px / 40px; */
#### 浮动

通过浮动可以使一个元素向其父元素的左侧或右侧移动
                    使用 float 属性来设置于元素的浮动
                        可选值：
                            none 默认值 ，元素不浮动
                            left 元素向左浮动
                            right 元素向右浮动

	注意，元素设置浮动以后，水平布局的等式便不需要强制成立
	    元素设置浮动以后，会完全从文档流中脱离，不再占用文档流的位置，
	    所以元素下边的还在文档流中的元素会自动向上移动
	
	浮动的特点：
	    1、浮动元素会完全脱离文档流，不再占据文档流中的位置
	    2、设置浮动以后元素会向父元素的左侧或右侧移动，
	    3、浮动元素默认不会从父元素中移出
	    4、浮动元素向左或向右移动时，不会超过它前边的其他浮动元素
	    5、如果浮动元素的上边是一个没有浮动的块元素，则浮动元素无法上移
	    6、浮动元素不会超过它上边的浮动的兄弟元素，最多最多就是和它一样高
	
	    简单总结：
	       浮动目前来讲它的主要作用就是让页面中的元素可以水平排列，
	       通过浮动可以制作一些水平方向的布局    


==浮动元素不会盖住文字==，文字会自动环绕在浮动元素的周围，
                    所以我们可以利用浮动来设置文字环绕图片的效果

元素设置浮动以后，将会从文档流中脱离，从文档流中脱离后，元素的一些特点也会发生变化

                脱离文档流的特点：
                    块元素：
                        1、块元素不在独占页面的一行
                        2、脱离文档流以后，块元素的宽度和高度默认都被内容撑开
    
                    行内元素：
                        行内元素脱离文档流以后会变成块元素，特点和块元素一样
    
                    脱离文档流以后，不需要再区分块和行内了

##### 高度塌陷

在浮动布局中，父元素的高度默认是被子元素撑开的，
	当子元素浮动后，其会完全脱离文档流，子元素从文档流中脱离
	将会无法撑起父元素的高度，导致父元素的高度丢失

​	父元素高度丢失以后，其下的元素会自动上移，导致页面的布局混乱 
​	所以高度塌陷是浮动布局中比较常见的一个问题，这个问题我们必须要进行处理！



##### BFC(Block Formatting Context) 块级格式化环境

​	BFC是一个CSS中的一个隐含的属性，可以为一个元素开启BFC
开启BFC该元素会变成一个独立的布局区域

​	元素开启BFC后的特点：
​		1.开启BFC的元素不会被浮动元素所覆盖
​		2.开启BFC的元素子元素和父元素外边距不会重叠
​		3.开启BFC的元素可以包含浮动的子元素

可以通过一些特殊方式来开启元素的BFC：
	1、设置元素的浮动（不推荐）
	2、将元素设置为行内块元素（不推荐）
	3、将元素的overflow设置为一个非visible的值

- 常用的方式 为元素设置 ==overflow:hidden== 开启其BFC 以使其可以包含浮动元素











